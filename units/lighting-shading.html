<!DOCTYPE html><html lang="en"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta charset="utf-8"><meta name="viewport" content="width=device-widthinitial-scale=1"><title>CG-Session</title><meta name="description" content="ToDo"><meta name="robots" content="index, follow"><link rel="stylesheet" href="../styles.css"><noscript><style class="js-only">{ display: none; }</style></noscript><body id="page-top" data-spy="scroll"><section class="container" id="lecture"><div class="row text-center"><div class="col-12"><div class="title"><img class="img-fluid" src="../webp-generated/fire-life-is-strange_f143.webp"><h2><strong>Beleuchtung</strong> und <strong>Schattierung</strong></h2></div><a href="../index.html">Zur√ºck zu <strong>Vorlesungs√ºbersicht</strong></a></div></div></section><div class="container"><div class="row"><div class="offset-1 col-10"><div class="alert alert-primary"><p>In dieser Einheit wird gezeigt, wie virtuelle Kameras in der Theorie und in der praktischen Umsetzung funktionieren und wie effizient 3D Szenen aus wohldefinierten Blickwinkeln dargestellt werden k√∂nnen.</p><hr><h4>Nach dieser Lehreinheit solltest Du&hellip;</h4><ul class="list-unstyled"><li>&hellip;die Bedeutung von Beleuchtung f√ºr die Computergrafik kennen,</li><li>&hellip;die Unterschiede zwischen lokalen und globalen Beleuchtungsmodellen erkl√§ren k√∂nnen, (shading und shadowing),</li><li>&hellip;verschiedene Lichtquellen-Modelle und deren Unterschiede sowie Anwendungszwecke zuordnen k√∂nnen</li><li>&hellip;die Bestandteile des phong-Beleuchtungsmodells kennen.</li><li>&hellip;Schattierungsverfahren kennen.</li></ul></div></div></div><div class="row"><div class="offset-1 col-10"><div class="alert alert-secondary"><h4>Vorwissen</h4></div></div></div></div><section class="container"><div class="row"><div class="offset-1 col-10"><h3>Motivation und Problemstellung</h3> <p>Ziel dieser Einheit soll es sein, zu verstehen, welche Rolle Beleuchtung in der Computergrafik spielt und wie simple lokale Beleuchtungsverfahren funktionieren. Bevor wir uns jedoch genauer mit der Umsetzung besch√§ftigen, m√ºssen wir uns zun√§chst erarbeiten, welche Eigenschaften virtuelle Beleuchtung auszeichnen.</p> <p>Wir wollen uns daf√ºr ein paar Aufnahmen aus verschiedenen Spielen ansehen. Welche Eigenschaften, die ein Beleuchtungsmodell charakterisieren, kannst du daraus ableiten?</p> <table> <thead> <tr> <th style="text-align:center"><img src="../webp-generated/fire-life-is-strange_f143.webp" alt="camera-model"></th> </tr> </thead> <tbody> <tr> <td style="text-align:center">üß© Beispielscreenshots</td> </tr> </tbody> </table> <textarea class="notes" rows="8" placeholder="Mach Dir ein paar Notizen wenn du magst."></textarea> <p>Wie auch auf den Screenshots zu erkennen, ist Beleuchtung ein zentrales Ausdrucksmittel und f√ºr 3D-Wahrnehmung wichtig. Sie vermittelt Betrachter*innen Informationen √ºber Oberfl√§chenbeschaffenheit und Form von Objekten und tr√§gt dadurch signifikant dazu bei, einen r√§umlichen Eindruck zu erzeugen.</p> <p>Um diese Informationen zu vermitteln, muss die Belechtung der Szene also in irgendeiner Form von der Oberfl√§che abh√§ngen, also insbesondere ihrer <strong>Ausrichtung</strong> sowie ihrem <strong>Material und Struktur</strong>. So w√ºrde z.B. ein Ball aus Gummi bei gleicher Beleuchtung anders aussehen als eine Kugel aus Metall.</p> <p>Dabei sind verschiedene Beleuchtungseffekte zu beobachten: Zum einen sind Fl√§chen st√§rker erleuchtet, je mehr sie dem Licht zugewandt sind, unabh√§ngig von der Kameraposition. Dieser Bestandteil der Beleuchtung nennt sich <strong>diffuse</strong> Beleuchtung. Zum anderen sind auch Glanzpunkte zu erkennen, deren Position sich in Abh√§ngigkeit von der Blickrichtung ver√§ndert. Diese <em>highlights</em> sind der <strong>spekulare</strong> Anteil der Beleuchtung.</p> <p>In der Computergrafik I m√∂chten wir zun√§chst darauf eingehen, wie diese beiden Effekte umgesetzt werden k√∂nnen, um grundlegend plausible Beleuchtung zu erzeugen, die von Oberfl√§chenausrichtung und -material abh√§ngig ist. Nat√ºrlich geh√∂rt f√ºr eine realistische Beleuchtung aber noch einiges mehr dazu. Weiterf√ºhrende Effekte, die in den Screenshots zu erkennen sind, sind z.B. <strong>indirekte Beleuchtung</strong> und <strong>Schattenwurf</strong>.</p> <p><strong>Direkte vs. Indirekte Beleuchtung</strong> <br> Direkte Beleuchtung bezeichnet alle Beleuchtungseffekte, die nur Licht ber√ºcksichtigen, das auf direktem Wege auf die Oberfl√§che trifft. U.a. werden Reflexion oder Refraktion von Licht durch andere Objekte zwischen der Oberfl√§che und der Lichtquelle nicht ber√ºcksichtigt. Wird beispielsweise eine wei√üe Wand angestrahlt, w√ºrde mit einer physikalisch korrekten Darstellung ein Teil des reflektierten Lichts andere Objekte der Szene erleuchten. Dieser Effekt kann durch Beleuchtungsmodelle mit rein direkter Beleuchtung nicht abgebildet werden.</p> <table> <thead> <tr> <th style="text-align:center"><img src="../webp-generated/cornell_660a.webp" alt="camera-model"></th> </tr> </thead> <tbody> <tr> <td style="text-align:center">üß© Cornell-Box direct vs indirect: Platzhalter</td> </tr> </tbody> </table> <p><strong>Schattierung vs. Schattenwurf</strong> <br> W√§hrend es bei der Schattierung darum geht, die Oberfl√§chenfarbe gem√§√ü Material und Ausrichtung gegen√ºber Lichtquelle und Kamera anzupassen, meint Schattenwurf das Entstehen von Schatten durch Hindernisse zwischen Oberfl√§che und Lichtquelle.</p> <table> <thead> <tr> <th style="text-align:center"><img src="../webp-generated/shadowing_d737.webp" alt="camera-model"></th> </tr> </thead> <tbody> <tr> <td style="text-align:center">üß© Shading/Shadowing</td> </tr> </tbody> </table> <p>Aber was macht diese Effekte so viel schwieriger umzusetzen als direkte Beleuchtung ohne Schattenwurf? Das liegt daran, welche Informationen jeweils ben√∂tigt werden, um das Ergebnis zu berechnen. F√ºr direkte Beleuchtung ohne Schatten reicht es aus, die Oberfl√§chennormale und die Positionen von Lichtquellen, Kamera und dem aktuellen Punkt auf der Oberfl√§che zu kennen. F√ºr indirekte Beleuchtung und Schattenwurf hingegen wird Information √ºber <em>alle</em> Objekte der Szene ben√∂tigt, die sich in irgendeiner Weise auf die Beleuchtung der aktuellen Oberfl√§che auswirken k√∂nnten. Zwischen all diesen Objekten kann das Licht zudem potenziell beliebig oft hin und her reflektiert werden, was die Beleuchtungsberechnung deutlich komplexer und rechenintensiver macht.</p> <p>Es gibt nat√ºrlich viele clevere Ans√§tze, um auch mit weniger Rechenkapazit√§t einige Aspekte komplexerer Beleuchtung umzusetzen. Einige davon, insbesondere Techniken zum Ann√§hern von Schatten, werden in Computergrafik II thematisiert.</p> <p>Zusammenfassung:</p> <ul> <li>Beleuchtung ist wichtig</li> <li>Beleuchtung vermittelt Informationen √ºber die Szene -&gt; insbesondere Position, Ausrichtung und Material von Oberfl√§chen</li> <li>es gibt diffuse und spekulare Beleuchtung</li> <li>direkte Beleuchtung ist leichter als indirekte</li> <li>Schattierung ist leichter als Schattenwurf</li> </ul> </div></div></section><section><img class="img-fluid" src="../webp-generated/transition_8204.webp"></section><div class="container-dark"><section class="container no-padding"><div class="row"><div class="offset-1 col-10"><h3>Physikalische Grundlagen</h3> <p><em>F√ºr eine detailliertere Einf√ºhrung in die physikalischen Grundlagen des Lichts empfehlen wir die Seite von Bartosz Ciechanowski <strong>&lt;insert link&gt;</strong>. F√ºr diese Einheit werden wir jedoch ein einfaches <strong>Strahlenmodell</strong> annehmen.</em></p> <p>Wir nehmen die Welt um uns dar√ºber wahr, wie Licht mit ihr interagiert. Wir k√∂nnen Objekte nur sehen, wenn sie mit Licht in Kontakt kommen und dieses entweder in Richtung Betrachter*in zur√ºckwerfen (<strong>Reflexion</strong>), durchlassen (<strong>Transmission</strong>) oder verschlucken (<strong>Absorption</strong>). Diese Erscheinungen nehmen Einfluss darauf wie hell oder dunkel ein Objekt wahrgenommen wird und bewirken dadurch Schattierung und Schattenwurf. Damit bilden sie auch die Grundlage f√ºr unser Beleuchtungsmodell.</p> <table> <thead> <tr> <th style="text-align:center"><img src="../webp-generated/ray_types_73a5.webp" alt="camera-model"></th> </tr> </thead> <tbody> <tr> <td style="text-align:center">Strahlentypen</td> </tr> </tbody> </table> <p>Weitere Ph√§nomene, die bei der Interaktion von Licht mit Objekten einer Szene auftreten k√∂nnen, sind z.B. Lichtbeugung und -brechung sowie Interferenzerscheinungen, diese spielen jedoch in den Lichtausbreitungsmodellen der Computergrafik in der Regel eine untergeordnete Rolle. Den Hauptfaktor bildet die <strong>Reflexion</strong>.</p> <h3>Reflexion</h3> <p>Wie bereits erw√§hnt unterscheiden wir zwischen <strong>diffuser</strong> und <strong>spekularer</strong> Reflexion, die zusammen unser (sehr simples) Beleuchtungsmodell bilden. Welche physikalischen Grundlagen bzw. welche Modellannahmen stecken dahinter?</p> <h4>Diffuse Reflexion</h4> <p>Als diffuse Reflexion wird der Effekt bezeichnet, dass Fl√§chen heller wirken, je mehr sie dem Licht zugewandt sind. Sie ist vollst√§ndig unabh√§ngig vom Betrachtungswinkel und nur von Oberfl√§chenausrichtung und Lichtposition bzw. Lichtrichtung abh√§ngig.</p> <p>Es steht die Modellannahme dahinter, dass das auf die Oberfl√§che auftreffende Licht gleichm√§√üig in alle Richtungen reflektiert wird. Dieses Ph√§nomen ist st√§rker, je rauer die Oberfl√§che ist.</p> <table> <thead> <tr> <th style="text-align:center"><img src="../webp-generated/diffuse_e892.webp" alt="camera-model"></th> </tr> </thead> <tbody> <tr> <td style="text-align:center">Diffuse Reflexion - modelliertes Verhalten</td> </tr> </tbody> </table> <p>Physikalisch l√§sst sich dieses Ph√§nomen damit begr√ºnden, dass raue Fl√§chen viele kleine Unebenheiten beinhalten. Wir k√∂nnen uns die Wirkung einer Lichtquelle als viele dicht nebeneinanderliegende Lichtstrahlen vorstellen (<strong>modellieren?</strong>).- Treffen diese auf die Fl√§che, werden sie in praktisch zuf√§llige Richtungen reflektiert. Durch dieses Verhalten der einzelnen Lichtstrahlen wird das Licht insgesamt ann√§hernd gleichm√§√üig in alle verschiedenen Richtungen reflektiert.</p> <table> <thead> <tr> <th style="text-align:center"><img src="../webp-generated/diffuse_zoom_c224.webp" alt="camera-model"></th> </tr> </thead> <tbody> <tr> <td style="text-align:center">Reflexion an Unebenheiten in der Oberfl√§che</td> </tr> </tbody> </table> <p>Wie viel Licht genau in Abh√§ngigkeit vom Lichteinfallswinkel reflektiert wird, l√§sst sich mithilfe des <strong>Lambertschen Gesetzes</strong> berechnen. Dieses besagt, dass die reflektierte Lichtmenge, also die Lichtintensit√§t <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.07847em">I</span></span></span></span></eq>, proportional zum Kosinus des Winkels zwischen der <strong>(invertierten)</strong> Einfallsrichtung des Lichtes und der Fl√§chennormale ist.</p> <table> <thead> <tr> <th style="text-align:center"><img src="../webp-generated/lambert_0e6d.webp" alt="camera-model"></th> </tr> </thead> <tbody> <tr> <td style="text-align:center">Lambertsches Gesetz</td> </tr> </tbody> </table> <p>Dieser Zusammenhang l√§sst sich auch aus folgender √úberlegung herleiten. Wir k√∂nnen uns das Licht als ein B√ºndel paralleler Lichtstrahlen mit gleichem Abstand vorstellen. Je gr√∂√üer der Winkel der Lichtstrahlen zur Fl√§chennormale ist, umso gr√∂√üer ist der Abstand, mit dem die Lichtstrahlen auf der Oberfl√§che aufkommen. Die gleiche Fl√§che wird also bei einem gr√∂√üeren Winkel von weniger Lichtstrahlen getroffen.</p> <div align="center"> <canvas class="zdog-canvas" width="760" height="340"></canvas> </div> <div align="center"> <img alt="Nach links und rechts ziehen, um Winkel zu √§ndern" src="../webp-generated/drag_53ec.png" height="50"> </div> <br> <p>Damit k√∂nnen wir also die Abh√§ngigkeit der diffusen Reflexion von sowohl der Oberfl√§chenbeschaffenheit als auch von der Lichtrichtung begr√ºnden.</p> <h4>Spekulare Reflexion</h4> <p>Im Gegensatz zur Diffusen Reflexion ist die Spekulare Reflexion (auch <em>spiegelnde Reflexion</em> oder <em>Spiegellicht</em>) nicht nur von der Oberfl√§chenbeschaffenheit und Lichtrichtung, sondern auch der Blickrichtung abh√§ngig.</p> <p>Hier ist die Modellannahme, dass sich das Licht (im Gegensatz zur gleichm√§√üigen diffusen Reflexion) ungleichm√§√üig und besonders konzentriert in eine Richtung spiegelt. Daraus ergibt sich auch die Abh√§ngigkeit von der Blickrichtung: Der Punkt erscheint umso heller, je √§hnlicher Blick- und Spiegelrichtung sind.</p> <p>Spekulare Reflexion ist st√§rker auf sehr glatten (z.B. polierten) Oberfl√§chen. Die Oberfl√§chenbeschaffenheit bestimmt dabei sowohl, wie stark die spekulare Reflexion ist, als auch wie schnell die Helligkeit mit zunehmender Abweichung zwischen Blick- und Spiegelrichtung abnimmt.</p> <table> <thead> <tr> <th style="text-align:center"><img src="../webp-generated/specular_0733.webp" alt="camera-model"></th> </tr> </thead> <tbody> <tr> <td style="text-align:center">Spekulare Reflexion</td> </tr> </tbody> </table> <p>Sei <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ±</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal" style="margin-right:.0037em">Œ±</span></span></span></span></eq> der Winkel zwischen Blick-und Reflexionsrichtung. Dann ist die Intensit√§t der Spekularen Reflexion proportional zu <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msup><mi>s</mi><mi>n</mi></msup><mi>Œ±</mi></mrow><annotation encoding="application/x-tex">cos^n \alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6644em"></span><span class="mord mathnormal">co</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.6644em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:.0037em">Œ±</span></span></span></span></eq>, wobei <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span></eq> materialspezifisch ist.</p> <table> <thead> <tr> <th style="text-align:center"><img src="../webp-generated/specular_formula_d654.webp" alt="camera-model"></th> </tr> </thead> <tbody> <tr> <td style="text-align:center">Spekulare Reflexion</td> </tr> </tbody> </table> <p>Die Spiegelrichtung <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span></eq> liegt in einer Ebene mit <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span></eq> und <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span></eq> und der Winkel zwischen <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span></eq> und <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span></eq> ist identisch zu dem Winkel zwischen <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span></eq> und <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span></eq>. Mit diesen Informationen k√∂nnen wir eine Berechnungformel f√ºr die Spiegelrichtung herleiten:</p> <p>Sei <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span></eq> die auf die Normale <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span></eq> projizierte Lichtrichtung <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span></eq>. Dann entspricht der Vektor <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span></eq> aus der folgenden Darstellung der Differenz aus <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span></eq> und <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span></eq>. <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo>=</mo><mo>‚àí</mo><mi>L</mi><mo>+</mo><mi>P</mi><mo>=</mo><mi>P</mi><mo>‚àí</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">S = -L + P = P - L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord">‚àí</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span></span></eqn></section></p> <p>Wie auch in der Abbildung gut erkennbar ist, entspricht der Reflexionsvektor <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span></eq> der Summe aus der Lichtrichtung <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span></eq> und zwei Mal <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span></eq>. <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo>=</mo><mi>L</mi><mo>+</mo><mn>2</mn><mo>‚ãÖ</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R = L + 2\cdot S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span></span></eqn></section> Damit gilt <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo>=</mo><mi>L</mi><mo>+</mo><mn>2</mn><mo>‚ãÖ</mo><mo stretchy="false">(</mo><mi>P</mi><mo>‚àí</mo><mi>L</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>‚ãÖ</mo><mi>P</mi><mo>‚àí</mo><mi>L</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">R = L + 2\cdot (P-L) = 2\cdot P - L.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span><span class="mord">.</span></span></span></span></span></eqn></section> Der Vektor <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span></span></span></span></eq> l√§sst sich wiederum durch Projektion von <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span></eq> auf <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span></eq> bestimmen. Den Kosinus von Theta k√∂nnen wir dabei mit dem Skalarprodukt aus <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span></eq> und <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span></eq> bestimmen. <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo>=</mo><mi>N</mi><mo>‚ãÖ</mo><mi>cos</mi><mo>‚Å°</mo><mi>Œ∏</mi><mo>=</mo><mi>N</mi><mo>‚ãÖ</mo><mo stretchy="false">‚ü®</mo><mi>N</mi><mo separator="true">,</mo><mi>L</mi><mo stretchy="false">‚ü©</mo></mrow><annotation encoding="application/x-tex">P = N\cdot \cos \theta = N \cdot \langle N, L\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6944em"></span><span class="mop">cos</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.02778em">Œ∏</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">‚ü®</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">L</span><span class="mclose">‚ü©</span></span></span></span></span></eqn></section> Wir erhalten also als Formel f√ºr die Reflexionsrichtung <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo>=</mo><mn>2</mn><mo>‚ãÖ</mo><mo stretchy="false">(</mo><mi>N</mi><mo>‚ãÖ</mo><mo stretchy="false">‚ü®</mo><mi>N</mi><mo separator="true">,</mo><mi>L</mi><mo stretchy="false">‚ü©</mo><mo stretchy="false">)</mo><mo>‚àí</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R = 2\cdot(N\cdot\langle N, L\rangle) - L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">‚ü®</span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">L</span><span class="mclose">‚ü©)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">‚àí</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal">L</span></span></span></span></span></eqn></section></p> <table> <thead> <tr> <th style="text-align:center"><img src="../webp-generated/specular_formula2_f8b4.webp" alt="camera-model"></th> </tr> </thead> <tbody> <tr> <td style="text-align:center">Berechnung der Spiegelrichtung</td> </tr> </tbody> </table> <ul> <li> <p>wie bekommen wir daraus Farben?</p> </li> <li> <p>half vector</p> </li> </ul> <div align="center"> <svg class="zdog-canvas-half-vector" width="760" height="340"></svg> </div> </div></div></section></div><script>/*!
 * Zdog v1.1.3
 * Round, flat, designer-friendly pseudo-3D engine
 * Licensed MIT
 * https://zzz.dog
 * Copyright 2020 Metafizzy
 */
(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e()}else{t.Zdog=e()}})(this,function t(){var e={};e.TAU=Math.PI*2;e.extend=function(t,e){for(var r in e){t[r]=e[r]}return t};e.lerp=function(t,e,r){return(e-t)*r+t};e.modulo=function(t,e){return(t%e+e)%e};var s={2:function(t){return t*t},3:function(t){return t*t*t},4:function(t){return t*t*t*t},5:function(t){return t*t*t*t*t}};e.easeInOut=function(t,e){if(e==1){return t}t=Math.max(0,Math.min(1,t));var r=t<.5;var i=r?t:1-t;i/=.5;var n=s[e]||s[2];var o=n(i);o/=2;return r?o:1-o};return e});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e()}else{t.Zdog.CanvasRenderer=e()}})(this,function t(){var n={isCanvas:true};n.begin=function(t){t.beginPath()};n.move=function(t,e,r){t.moveTo(r.x,r.y)};n.line=function(t,e,r){t.lineTo(r.x,r.y)};n.bezier=function(t,e,r,i,n){t.bezierCurveTo(r.x,r.y,i.x,i.y,n.x,n.y)};n.closePath=function(t){t.closePath()};n.setPath=function(){};n.renderPath=function(e,r,t,i){this.begin(e,r);t.forEach(function(t){t.render(e,r,n)});if(i){this.closePath(e,r)}};n.stroke=function(t,e,r,i,n){if(!r){return}t.strokeStyle=i;t.lineWidth=n;t.stroke()};n.fill=function(t,e,r,i){if(!r){return}t.fillStyle=i;t.fill()};n.end=function(){};return n});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e()}else{t.Zdog.SvgRenderer=e()}})(this,function t(){var o={isSvg:true};var e=o.round=function(t){return Math.round(t*1e3)/1e3};function s(t){return e(t.x)+","+e(t.y)+" "}o.begin=function(){};o.move=function(t,e,r){return"M"+s(r)};o.line=function(t,e,r){return"L"+s(r)};o.bezier=function(t,e,r,i,n){return"C"+s(r)+s(i)+s(n)};o.closePath=function(){return"Z"};o.setPath=function(t,e,r){e.setAttribute("d",r)};o.renderPath=function(e,r,t,i){var n="";t.forEach(function(t){n+=t.render(e,r,o)});if(i){n+=this.closePath(e,r)}this.setPath(e,r,n)};o.stroke=function(t,e,r,i,n){if(!r){return}e.setAttribute("stroke",i);e.setAttribute("stroke-width",n)};o.fill=function(t,e,r,i){var n=r?i:"none";e.setAttribute("fill",n)};o.end=function(t,e){t.appendChild(e)};return o});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./boilerplate"))}else{var r=t.Zdog;r.Vector=e(r)}})(this,function t(r){function e(t){this.set(t)}var h=r.TAU;e.prototype.set=function(t){this.x=t&&t.x||0;this.y=t&&t.y||0;this.z=t&&t.z||0;return this};e.prototype.write=function(t){if(!t){return this}this.x=t.x!=undefined?t.x:this.x;this.y=t.y!=undefined?t.y:this.y;this.z=t.z!=undefined?t.z:this.z;return this};e.prototype.rotate=function(t){if(!t){return}this.rotateZ(t.z);this.rotateY(t.y);this.rotateX(t.x);return this};e.prototype.rotateZ=function(t){i(this,t,"x","y")};e.prototype.rotateX=function(t){i(this,t,"y","z")};e.prototype.rotateY=function(t){i(this,t,"x","z")};function i(t,e,r,i){if(!e||e%h===0){return}var n=Math.cos(e);var o=Math.sin(e);var s=t[r];var a=t[i];t[r]=s*n-a*o;t[i]=a*n+s*o}e.prototype.isSame=function(t){if(!t){return false}return this.x===t.x&&this.y===t.y&&this.z===t.z};e.prototype.add=function(t){if(!t){return this}this.x+=t.x||0;this.y+=t.y||0;this.z+=t.z||0;return this};e.prototype.subtract=function(t){if(!t){return this}this.x-=t.x||0;this.y-=t.y||0;this.z-=t.z||0;return this};e.prototype.multiply=function(t){if(t==undefined){return this}if(typeof t=="number"){this.x*=t;this.y*=t;this.z*=t}else{this.x*=t.x!=undefined?t.x:1;this.y*=t.y!=undefined?t.y:1;this.z*=t.z!=undefined?t.z:1}return this};e.prototype.transform=function(t,e,r){this.multiply(r);this.rotate(e);this.add(t);return this};e.prototype.lerp=function(t,e){this.x=r.lerp(this.x,t.x||0,e);this.y=r.lerp(this.y,t.y||0,e);this.z=r.lerp(this.z,t.z||0,e);return this};e.prototype.magnitude=function(){var t=this.x*this.x+this.y*this.y+this.z*this.z;return n(t)};function n(t){if(Math.abs(t-1)<1e-8){return 1}return Math.sqrt(t)}e.prototype.magnitude2d=function(){var t=this.x*this.x+this.y*this.y;return n(t)};e.prototype.copy=function(){return new e(this)};return e});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./boilerplate"),require("./vector"),require("./canvas-renderer"),require("./svg-renderer"))}else{var r=t.Zdog;r.Anchor=e(r,r.Vector,r.CanvasRenderer,r.SvgRenderer)}})(this,function t(n,e,r,i){var o=n.TAU;var s={x:1,y:1,z:1};function a(t){this.create(t||{})}a.prototype.create=function(t){this.children=[];n.extend(this,this.constructor.defaults);this.setOptions(t);this.translate=new e(t.translate);this.rotate=new e(t.rotate);this.scale=new e(s).multiply(this.scale);this.origin=new e;this.renderOrigin=new e;if(this.addTo){this.addTo.addChild(this)}};a.defaults={};a.optionKeys=Object.keys(a.defaults).concat(["rotate","translate","scale","addTo"]);a.prototype.setOptions=function(t){var e=this.constructor.optionKeys;for(var r in t){if(e.indexOf(r)!=-1){this[r]=t[r]}}};a.prototype.addChild=function(t){if(this.children.indexOf(t)!=-1){return}t.remove();t.addTo=this;this.children.push(t)};a.prototype.removeChild=function(t){var e=this.children.indexOf(t);if(e!=-1){this.children.splice(e,1)}};a.prototype.remove=function(){if(this.addTo){this.addTo.removeChild(this)}};a.prototype.update=function(){this.reset();this.children.forEach(function(t){t.update()});this.transform(this.translate,this.rotate,this.scale)};a.prototype.reset=function(){this.renderOrigin.set(this.origin)};a.prototype.transform=function(e,r,i){this.renderOrigin.transform(e,r,i);this.children.forEach(function(t){t.transform(e,r,i)})};a.prototype.updateGraph=function(){this.update();this.updateFlatGraph();this.flatGraph.forEach(function(t){t.updateSortValue()});this.flatGraph.sort(a.shapeSorter)};a.shapeSorter=function(t,e){return t.sortValue-e.sortValue};Object.defineProperty(a.prototype,"flatGraph",{get:function(){if(!this._flatGraph){this.updateFlatGraph()}return this._flatGraph},set:function(t){this._flatGraph=t}});a.prototype.updateFlatGraph=function(){this.flatGraph=this.getFlatGraph()};a.prototype.getFlatGraph=function(){var t=[this];return this.addChildFlatGraph(t)};a.prototype.addChildFlatGraph=function(r){this.children.forEach(function(t){var e=t.getFlatGraph();Array.prototype.push.apply(r,e)});return r};a.prototype.updateSortValue=function(){this.sortValue=this.renderOrigin.z};a.prototype.render=function(){};a.prototype.renderGraphCanvas=function(e){if(!e){throw new Error("ctx is "+e+". "+"Canvas context required for render. Check .renderGraphCanvas( ctx ).")}this.flatGraph.forEach(function(t){t.render(e,r)})};a.prototype.renderGraphSvg=function(e){if(!e){throw new Error("svg is "+e+". "+"SVG required for render. Check .renderGraphSvg( svg ).")}this.flatGraph.forEach(function(t){t.render(e,i)})};a.prototype.copy=function(t){var e={};var r=this.constructor.optionKeys;r.forEach(function(t){e[t]=this[t]},this);n.extend(e,t);var i=this.constructor;return new i(e)};a.prototype.copyGraph=function(t){var e=this.copy(t);this.children.forEach(function(t){t.copyGraph({addTo:e})});return e};a.prototype.normalizeRotate=function(){this.rotate.x=n.modulo(this.rotate.x,o);this.rotate.y=n.modulo(this.rotate.y,o);this.rotate.z=n.modulo(this.rotate.z,o)};function h(r){return function(t){function e(t){this.create(t||{})}e.prototype=Object.create(r.prototype);e.prototype.constructor=e;e.defaults=n.extend({},r.defaults);n.extend(e.defaults,t);e.optionKeys=r.optionKeys.slice(0);Object.keys(e.defaults).forEach(function(t){if(!e.optionKeys.indexOf(t)!=1){e.optionKeys.push(t)}});e.subclass=h(e);return e}}a.subclass=h(a);return a});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e()}else{t.Zdog.Dragger=e()}})(this,function t(){var r=typeof window!="undefined";var e="mousedown";var i="mousemove";var n="mouseup";if(r){if(window.PointerEvent){e="pointerdown";i="pointermove";n="pointerup"}else if("ontouchstart"in window){e="touchstart";i="touchmove";n="touchend"}}function o(){}function s(t){this.create(t||{})}s.prototype.create=function(t){this.onDragStart=t.onDragStart||o;this.onDragMove=t.onDragMove||o;this.onDragEnd=t.onDragEnd||o;this.bindDrag(t.startElement)};s.prototype.bindDrag=function(t){t=this.getQueryElement(t);if(!t){return}t.style.touchAction="none";t.addEventListener(e,this)};s.prototype.getQueryElement=function(t){if(typeof t=="string"){t=document.querySelector(t)}return t};s.prototype.handleEvent=function(t){var e=this["on"+t.type];if(e){e.call(this,t)}};s.prototype.onmousedown=s.prototype.onpointerdown=function(t){this.dragStart(t,t)};s.prototype.ontouchstart=function(t){this.dragStart(t,t.changedTouches[0])};s.prototype.dragStart=function(t,e){t.preventDefault();this.dragStartX=e.pageX;this.dragStartY=e.pageY;if(r){window.addEventListener(i,this);window.addEventListener(n,this)}this.onDragStart(e)};s.prototype.ontouchmove=function(t){this.dragMove(t,t.changedTouches[0])};s.prototype.onmousemove=s.prototype.onpointermove=function(t){this.dragMove(t,t)};s.prototype.dragMove=function(t,e){t.preventDefault();var r=e.pageX-this.dragStartX;var i=e.pageY-this.dragStartY;this.onDragMove(e,r,i)};s.prototype.onmouseup=s.prototype.onpointerup=s.prototype.ontouchend=s.prototype.dragEnd=function(){window.removeEventListener(i,this);window.removeEventListener(n,this);this.onDragEnd()};return s});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./boilerplate"),require("./anchor"),require("./dragger"))}else{var r=t.Zdog;r.Illustration=e(r,r.Anchor,r.Dragger)}})(this,function t(e,r,a){function i(){}var h=e.TAU;var n=r.subclass({element:undefined,centered:true,zoom:1,dragRotate:false,resize:false,onPrerender:i,onDragStart:i,onDragMove:i,onDragEnd:i,onResize:i});e.extend(n.prototype,a.prototype);n.prototype.create=function(t){r.prototype.create.call(this,t);a.prototype.create.call(this,t);this.setElement(this.element);this.setDragRotate(this.dragRotate);this.setResize(this.resize)};n.prototype.setElement=function(t){t=this.getQueryElement(t);if(!t){throw new Error("Zdog.Illustration element required. Set to "+t)}var e=t.nodeName.toLowerCase();if(e=="canvas"){this.setCanvas(t)}else if(e=="svg"){this.setSvg(t)}};n.prototype.setSize=function(t,e){t=Math.round(t);e=Math.round(e);if(this.isCanvas){this.setSizeCanvas(t,e)}else if(this.isSvg){this.setSizeSvg(t,e)}};n.prototype.setResize=function(t){this.resize=t;if(!this.resizeListener){this.resizeListener=this.onWindowResize.bind(this)}if(t){window.addEventListener("resize",this.resizeListener);this.onWindowResize()}else{window.removeEventListener("resize",this.resizeListener)}};n.prototype.onWindowResize=function(){this.setMeasuredSize();this.onResize(this.width,this.height)};n.prototype.setMeasuredSize=function(){var t,e;var r=this.resize=="fullscreen";if(r){t=window.innerWidth;e=window.innerHeight}else{var i=this.element.getBoundingClientRect();t=i.width;e=i.height}this.setSize(t,e)};n.prototype.renderGraph=function(t){if(this.isCanvas){this.renderGraphCanvas(t)}else if(this.isSvg){this.renderGraphSvg(t)}};n.prototype.updateRenderGraph=function(t){this.updateGraph();this.renderGraph(t)};n.prototype.setCanvas=function(t){this.element=t;this.isCanvas=true;this.ctx=this.element.getContext("2d");this.setSizeCanvas(t.width,t.height)};n.prototype.setSizeCanvas=function(t,e){this.width=t;this.height=e;var r=this.pixelRatio=window.devicePixelRatio||1;this.element.width=this.canvasWidth=t*r;this.element.height=this.canvasHeight=e*r;var i=r>1&&!this.resize;if(i){this.element.style.width=t+"px";this.element.style.height=e+"px"}};n.prototype.renderGraphCanvas=function(t){t=t||this;this.prerenderCanvas();r.prototype.renderGraphCanvas.call(t,this.ctx);this.postrenderCanvas()};n.prototype.prerenderCanvas=function(){var t=this.ctx;t.lineCap="round";t.lineJoin="round";t.clearRect(0,0,this.canvasWidth,this.canvasHeight);t.save();if(this.centered){var e=this.width/2*this.pixelRatio;var r=this.height/2*this.pixelRatio;t.translate(e,r)}var i=this.pixelRatio*this.zoom;t.scale(i,i);this.onPrerender(t)};n.prototype.postrenderCanvas=function(){this.ctx.restore()};n.prototype.setSvg=function(t){this.element=t;this.isSvg=true;this.pixelRatio=1;var e=t.getAttribute("width");var r=t.getAttribute("height");this.setSizeSvg(e,r)};n.prototype.setSizeSvg=function(t,e){this.width=t;this.height=e;var r=t/this.zoom;var i=e/this.zoom;var n=this.centered?-r/2:0;var o=this.centered?-i/2:0;this.element.setAttribute("viewBox",n+" "+o+" "+r+" "+i);if(this.resize){this.element.removeAttribute("width");this.element.removeAttribute("height")}else{this.element.setAttribute("width",t);this.element.setAttribute("height",e)}};n.prototype.renderGraphSvg=function(t){t=t||this;o(this.element);this.onPrerender(this.element);r.prototype.renderGraphSvg.call(t,this.element)};function o(t){while(t.firstChild){t.removeChild(t.firstChild)}}n.prototype.setDragRotate=function(t){if(!t){return}else if(t===true){t=this}this.dragRotate=t;this.bindDrag(this.element)};n.prototype.dragStart=function(){this.dragStartRX=this.dragRotate.rotate.x;this.dragStartRY=this.dragRotate.rotate.y;a.prototype.dragStart.apply(this,arguments)};n.prototype.dragMove=function(t,e){var r=e.pageX-this.dragStartX;var i=e.pageY-this.dragStartY;var n=Math.min(this.width,this.height);var o=r/n*h;var s=i/n*h;this.dragRotate.rotate.x=this.dragStartRX-s;this.dragRotate.rotate.y=this.dragStartRY-o;a.prototype.dragMove.apply(this,arguments)};return n});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./vector"))}else{var r=t.Zdog;r.PathCommand=e(r.Vector)}})(this,function t(i){function e(t,e,r){this.method=t;this.points=e.map(n);this.renderPoints=e.map(o);this.previousPoint=r;this.endRenderPoint=this.renderPoints[this.renderPoints.length-1];if(t=="arc"){this.controlPoints=[new i,new i]}}function n(t){if(t instanceof i){return t}else{return new i(t)}}function o(t){return new i(t)}e.prototype.reset=function(){var i=this.points;this.renderPoints.forEach(function(t,e){var r=i[e];t.set(r)})};e.prototype.transform=function(e,r,i){this.renderPoints.forEach(function(t){t.transform(e,r,i)})};e.prototype.render=function(t,e,r){return this[this.method](t,e,r)};e.prototype.move=function(t,e,r){return r.move(t,e,this.renderPoints[0])};e.prototype.line=function(t,e,r){return r.line(t,e,this.renderPoints[0])};e.prototype.bezier=function(t,e,r){var i=this.renderPoints[0];var n=this.renderPoints[1];var o=this.renderPoints[2];return r.bezier(t,e,i,n,o)};var h=9/16;e.prototype.arc=function(t,e,r){var i=this.previousPoint;var n=this.renderPoints[0];var o=this.renderPoints[1];var s=this.controlPoints[0];var a=this.controlPoints[1];s.set(i).lerp(n,h);a.set(o).lerp(n,h);return r.bezier(t,e,s,a,o)};return e});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./boilerplate"),require("./vector"),require("./path-command"),require("./anchor"))}else{var r=t.Zdog;r.Shape=e(r,r.Vector,r.PathCommand,r.Anchor)}})(this,function t(e,r,p,i){var n=i.subclass({stroke:1,fill:false,color:"#333",closed:true,visible:true,path:[{}],front:{z:1},backface:true});n.prototype.create=function(t){i.prototype.create.call(this,t);this.updatePath();this.front=new r(t.front||this.front);this.renderFront=new r(this.front);this.renderNormal=new r};var d=["move","line","bezier","arc"];n.prototype.updatePath=function(){this.setPath();this.updatePathCommands()};n.prototype.setPath=function(){};n.prototype.updatePathCommands=function(){var u;this.pathCommands=this.path.map(function(t,e){var r=Object.keys(t);var i=r[0];var n=t[i];var o=r.length==1&&d.indexOf(i)!=-1;if(!o){i="line";n=t}var s=i=="line"||i=="move";var a=Array.isArray(n);if(s&&!a){n=[n]}i=e===0?"move":i;var h=new p(i,n,u);u=h.endRenderPoint;return h})};n.prototype.reset=function(){this.renderOrigin.set(this.origin);this.renderFront.set(this.front);this.pathCommands.forEach(function(t){t.reset()})};n.prototype.transform=function(e,r,i){this.renderOrigin.transform(e,r,i);this.renderFront.transform(e,r,i);this.renderNormal.set(this.renderOrigin).subtract(this.renderFront);this.pathCommands.forEach(function(t){t.transform(e,r,i)});this.children.forEach(function(t){t.transform(e,r,i)})};n.prototype.updateSortValue=function(){var t=this.pathCommands.length;var e=this.pathCommands[0].endRenderPoint;var r=this.pathCommands[t-1].endRenderPoint;var i=t>2&&e.isSame(r);if(i){t-=1}var n=0;for(var o=0;o<t;o++){n+=this.pathCommands[o].endRenderPoint.z}this.sortValue=n/t};n.prototype.render=function(t,e){var r=this.pathCommands.length;if(!this.visible||!r){return}this.isFacingBack=this.renderNormal.z>0;if(!this.backface&&this.isFacingBack){return}if(!e){throw new Error("Zdog renderer required. Set to "+e)}var i=r==1;if(e.isCanvas&&i){this.renderCanvasDot(t,e)}else{this.renderPath(t,e)}};var o=e.TAU;n.prototype.renderCanvasDot=function(t){var e=this.getLineWidth();if(!e){return}t.fillStyle=this.getRenderColor();var r=this.pathCommands[0].endRenderPoint;t.beginPath();var i=e/2;t.arc(r.x,r.y,i,0,o);t.fill()};n.prototype.getLineWidth=function(){if(!this.stroke){return 0}if(this.stroke==true){return 1}return this.stroke};n.prototype.getRenderColor=function(){var t=typeof this.backface=="string"&&this.isFacingBack;var e=t?this.backface:this.color;return e};n.prototype.renderPath=function(t,e){var r=this.getRenderElement(t,e);var i=this.pathCommands.length==2&&this.pathCommands[1].method=="line";var n=!i&&this.closed;var o=this.getRenderColor();e.renderPath(t,r,this.pathCommands,n);e.stroke(t,r,this.stroke,o,this.getLineWidth());e.fill(t,r,this.fill,o);e.end(t,r)};var s="http://www.w3.org/2000/svg";n.prototype.getRenderElement=function(t,e){if(!e.isSvg){return}if(!this.svgElement){this.svgElement=document.createElementNS(s,"path");this.svgElement.setAttribute("stroke-linecap","round");this.svgElement.setAttribute("stroke-linejoin","round")}return this.svgElement};return n});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./anchor"))}else{var r=t.Zdog;r.Group=e(r.Anchor)}})(this,function t(r){var e=r.subclass({updateSort:false,visible:true});e.prototype.updateSortValue=function(){var e=0;this.flatGraph.forEach(function(t){t.updateSortValue();e+=t.sortValue});this.sortValue=e/this.flatGraph.length;if(this.updateSort){this.flatGraph.sort(r.shapeSorter)}};e.prototype.render=function(e,r){if(!this.visible){return}this.flatGraph.forEach(function(t){t.render(e,r)})};e.prototype.updateFlatGraph=function(){var t=[];this.flatGraph=this.addChildFlatGraph(t)};e.prototype.getFlatGraph=function(){return[this]};return e});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./shape"))}else{var r=t.Zdog;r.Rect=e(r.Shape)}})(this,function t(e){var r=e.subclass({width:1,height:1});r.prototype.setPath=function(){var t=this.width/2;var e=this.height/2;this.path=[{x:-t,y:-e},{x:t,y:-e},{x:t,y:e},{x:-t,y:e}]};return r});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./shape"))}else{var r=t.Zdog;r.RoundedRect=e(r.Shape)}})(this,function t(e){var r=e.subclass({width:1,height:1,cornerRadius:.25,closed:false});r.prototype.setPath=function(){var t=this.width/2;var e=this.height/2;var r=Math.min(t,e);var i=Math.min(this.cornerRadius,r);var n=t-i;var o=e-i;var s=[{x:n,y:-e},{arc:[{x:t,y:-e},{x:t,y:-o}]}];if(o){s.push({x:t,y:o})}s.push({arc:[{x:t,y:e},{x:n,y:e}]});if(n){s.push({x:-n,y:e})}s.push({arc:[{x:-t,y:e},{x:-t,y:o}]});if(o){s.push({x:-t,y:-o})}s.push({arc:[{x:-t,y:-e},{x:-n,y:-e}]});if(n){s.push({x:n,y:-e})}this.path=s};return r});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./shape"))}else{var r=t.Zdog;r.Ellipse=e(r.Shape)}})(this,function t(e){var r=e.subclass({diameter:1,width:undefined,height:undefined,quarters:4,closed:false});r.prototype.setPath=function(){var t=this.width!=undefined?this.width:this.diameter;var e=this.height!=undefined?this.height:this.diameter;var r=t/2;var i=e/2;this.path=[{x:0,y:-i},{arc:[{x:r,y:-i},{x:r,y:0}]}];if(this.quarters>1){this.path.push({arc:[{x:r,y:i},{x:0,y:i}]})}if(this.quarters>2){this.path.push({arc:[{x:-r,y:i},{x:-r,y:0}]})}if(this.quarters>3){this.path.push({arc:[{x:-r,y:-i},{x:0,y:-i}]})}};return r});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./boilerplate"),require("./shape"))}else{var r=t.Zdog;r.Polygon=e(r,r.Shape)}})(this,function t(e,r){var i=r.subclass({sides:3,radius:.5});var n=e.TAU;i.prototype.setPath=function(){this.path=[];for(var t=0;t<this.sides;t++){var e=t/this.sides*n-n/4;var r=Math.cos(e)*this.radius;var i=Math.sin(e)*this.radius;this.path.push({x:r,y:i})}};return i});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./boilerplate"),require("./vector"),require("./anchor"),require("./ellipse"))}else{var r=t.Zdog;r.Hemisphere=e(r,r.Vector,r.Anchor,r.Ellipse)}})(this,function t(e,r,i,n){var o=n.subclass({fill:true});var u=e.TAU;o.prototype.create=function(){n.prototype.create.apply(this,arguments);this.apex=new i({addTo:this,translate:{z:this.diameter/2}});this.renderCentroid=new r};o.prototype.updateSortValue=function(){this.renderCentroid.set(this.renderOrigin).lerp(this.apex.renderOrigin,3/8);this.sortValue=this.renderCentroid.z};o.prototype.render=function(t,e){this.renderDome(t,e);n.prototype.render.apply(this,arguments)};o.prototype.renderDome=function(t,e){if(!this.visible){return}var r=this.getDomeRenderElement(t,e);var i=Math.atan2(this.renderNormal.y,this.renderNormal.x);var n=this.diameter/2*this.renderNormal.magnitude();var o=this.renderOrigin.x;var s=this.renderOrigin.y;if(e.isCanvas){var a=i+u/4;var h=i-u/4;t.beginPath();t.arc(o,s,n,a,h)}else if(e.isSvg){i=(i-u/4)/u*360;this.domeSvgElement.setAttribute("d","M "+-n+",0 A "+n+","+n+" 0 0 1 "+n+",0");this.domeSvgElement.setAttribute("transform","translate("+o+","+s+" ) rotate("+i+")")}e.stroke(t,r,this.stroke,this.color,this.getLineWidth());e.fill(t,r,this.fill,this.color);e.end(t,r)};var s="http://www.w3.org/2000/svg";o.prototype.getDomeRenderElement=function(t,e){if(!e.isSvg){return}if(!this.domeSvgElement){this.domeSvgElement=document.createElementNS(s,"path");this.domeSvgElement.setAttribute("stroke-linecap","round");this.domeSvgElement.setAttribute("stroke-linejoin","round")}return this.domeSvgElement};return o});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./boilerplate"),require("./path-command"),require("./shape"),require("./group"),require("./ellipse"))}else{var r=t.Zdog;r.Cylinder=e(r,r.PathCommand,r.Shape,r.Group,r.Ellipse)}})(this,function t(e,r,i,n,o){function s(){}var a=n.subclass({color:"#333",updateSort:true});a.prototype.create=function(){n.prototype.create.apply(this,arguments);this.pathCommands=[new r("move",[{}]),new r("line",[{}])]};a.prototype.render=function(t,e){this.renderCylinderSurface(t,e);n.prototype.render.apply(this,arguments)};a.prototype.renderCylinderSurface=function(t,e){if(!this.visible){return}var r=this.getRenderElement(t,e);var i=this.frontBase;var n=this.rearBase;var o=i.renderNormal.magnitude();var s=i.diameter*o+i.getLineWidth();this.pathCommands[0].renderPoints[0].set(i.renderOrigin);this.pathCommands[1].renderPoints[0].set(n.renderOrigin);if(e.isCanvas){t.lineCap="butt"}e.renderPath(t,r,this.pathCommands);e.stroke(t,r,true,this.color,s);e.end(t,r);if(e.isCanvas){t.lineCap="round"}};var h="http://www.w3.org/2000/svg";a.prototype.getRenderElement=function(t,e){if(!e.isSvg){return}if(!this.svgElement){this.svgElement=document.createElementNS(h,"path")}return this.svgElement};a.prototype.copyGraph=s;var u=o.subclass();u.prototype.copyGraph=s;var p=i.subclass({diameter:1,length:1,frontFace:undefined,fill:true});var d=e.TAU;p.prototype.create=function(){i.prototype.create.apply(this,arguments);this.group=new a({addTo:this,color:this.color,visible:this.visible});var t=this.length/2;var e=this.backface||true;this.frontBase=this.group.frontBase=new o({addTo:this.group,diameter:this.diameter,translate:{z:t},rotate:{y:d/2},color:this.color,stroke:this.stroke,fill:this.fill,backface:this.frontFace||e,visible:this.visible});this.rearBase=this.group.rearBase=this.frontBase.copy({translate:{z:-t},rotate:{y:0},backface:e})};p.prototype.render=function(){};var c=["stroke","fill","color","visible"];c.forEach(function(e){var r="_"+e;Object.defineProperty(p.prototype,e,{get:function(){return this[r]},set:function(t){this[r]=t;if(this.frontBase){this.frontBase[e]=t;this.rearBase[e]=t;this.group[e]=t}}})});return p});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./boilerplate"),require("./vector"),require("./path-command"),require("./anchor"),require("./ellipse"))}else{var r=t.Zdog;r.Cone=e(r,r.Vector,r.PathCommand,r.Anchor,r.Ellipse)}})(this,function t(e,r,i,n,o){var s=o.subclass({length:1,fill:true});var v=e.TAU;s.prototype.create=function(){o.prototype.create.apply(this,arguments);this.apex=new n({addTo:this,translate:{z:this.length}});this.renderApex=new r;this.renderCentroid=new r;this.tangentA=new r;this.tangentB=new r;this.surfacePathCommands=[new i("move",[{}]),new i("line",[{}]),new i("line",[{}])]};s.prototype.updateSortValue=function(){this.renderCentroid.set(this.renderOrigin).lerp(this.apex.renderOrigin,1/3);this.sortValue=this.renderCentroid.z};s.prototype.render=function(t,e){this.renderConeSurface(t,e);o.prototype.render.apply(this,arguments)};s.prototype.renderConeSurface=function(t,e){if(!this.visible){return}this.renderApex.set(this.apex.renderOrigin).subtract(this.renderOrigin);var r=this.renderNormal.magnitude();var i=this.renderApex.magnitude2d();var n=this.renderNormal.magnitude2d();var o=Math.acos(n/r);var s=Math.sin(o);var a=this.diameter/2*r;var h=a*s<i;if(!h){return}var u=Math.atan2(this.renderNormal.y,this.renderNormal.x)+v/2;var p=i/s;var d=Math.acos(a/p);var c=this.tangentA;var f=this.tangentB;c.x=Math.cos(d)*a*s;c.y=Math.sin(d)*a;f.set(this.tangentA);f.y*=-1;c.rotateZ(u);f.rotateZ(u);c.add(this.renderOrigin);f.add(this.renderOrigin);this.setSurfaceRenderPoint(0,c);this.setSurfaceRenderPoint(1,this.apex.renderOrigin);this.setSurfaceRenderPoint(2,f);var l=this.getSurfaceRenderElement(t,e);e.renderPath(t,l,this.surfacePathCommands);e.stroke(t,l,this.stroke,this.color,this.getLineWidth());e.fill(t,l,this.fill,this.color);e.end(t,l)};var a="http://www.w3.org/2000/svg";s.prototype.getSurfaceRenderElement=function(t,e){if(!e.isSvg){return}if(!this.surfaceSvgElement){this.surfaceSvgElement=document.createElementNS(a,"path");this.surfaceSvgElement.setAttribute("stroke-linecap","round");this.surfaceSvgElement.setAttribute("stroke-linejoin","round")}return this.surfaceSvgElement};s.prototype.setSurfaceRenderPoint=function(t,e){var r=this.surfacePathCommands[t].renderPoints[0];r.set(e)};return s});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./boilerplate"),require("./anchor"),require("./shape"),require("./rect"))}else{var r=t.Zdog;r.Box=e(r,r.Anchor,r.Shape,r.Rect)}})(this,function t(e,r,i,n){var o=n.subclass();o.prototype.copyGraph=function(){};var s=e.TAU;var a=["frontFace","rearFace","leftFace","rightFace","topFace","bottomFace"];var h=e.extend({},i.defaults);delete h.path;a.forEach(function(t){h[t]=true});e.extend(h,{width:1,height:1,depth:1,fill:true});var u=r.subclass(h);u.prototype.create=function(t){r.prototype.create.call(this,t);this.updatePath();this.fill=this.fill};u.prototype.updatePath=function(){a.forEach(function(t){this[t]=this[t]},this)};a.forEach(function(e){var r="_"+e;Object.defineProperty(u.prototype,e,{get:function(){return this[r]},set:function(t){this[r]=t;this.setFace(e,t)}})});u.prototype.setFace=function(t,e){var r=t+"Rect";var i=this[r];if(!e){this.removeChild(i);return}var n=this.getFaceOptions(t);n.color=typeof e=="string"?e:this.color;if(i){i.setOptions(n)}else{i=this[r]=new o(n)}i.updatePath();this.addChild(i)};u.prototype.getFaceOptions=function(t){return{frontFace:{width:this.width,height:this.height,translate:{z:this.depth/2}},rearFace:{width:this.width,height:this.height,translate:{z:-this.depth/2},rotate:{y:s/2}},leftFace:{width:this.depth,height:this.height,translate:{x:-this.width/2},rotate:{y:-s/4}},rightFace:{width:this.depth,height:this.height,translate:{x:this.width/2},rotate:{y:s/4}},topFace:{width:this.width,height:this.depth,translate:{y:-this.height/2},rotate:{x:-s/4}},bottomFace:{width:this.width,height:this.depth,translate:{y:this.height/2},rotate:{x:s/4}}}[t]};var p=["color","stroke","fill","backface","front","visible"];p.forEach(function(o){var t="_"+o;Object.defineProperty(u.prototype,o,{get:function(){return this[t]},set:function(n){this[t]=n;a.forEach(function(t){var e=this[t+"Rect"];var r=typeof this[t]=="string";var i=o=="color"&&r;if(e&&!i){e[o]=n}},this)}})});return u});(function(t,e){if(typeof module=="object"&&module.exports){module.exports=e(require("./boilerplate"),require("./canvas-renderer"),require("./svg-renderer"),require("./vector"),require("./anchor"),require("./dragger"),require("./illustration"),require("./path-command"),require("./shape"),require("./group"),require("./rect"),require("./rounded-rect"),require("./ellipse"),require("./polygon"),require("./hemisphere"),require("./cylinder"),require("./cone"),require("./box"))}else if(typeof define=="function"&&define.amd){define("zdog",[],t.Zdog)}})(this,function t(e,r,i,n,o,s,a,h,u,p,d,c,f,l,v,y,m,g){e.CanvasRenderer=r;e.SvgRenderer=i;e.Vector=n;e.Anchor=o;e.Dragger=s;e.Illustration=a;e.PathCommand=h;e.Shape=u;e.Group=p;e.Rect=d;e.RoundedRect=c;e.Ellipse=f;e.Polygon=l;e.Hemisphere=v;e.Cylinder=y;e.Cone=m;e.Box=g;return e});</script><script>// Made with Zdog
// {} for namespace
  let illo2 = new Zdog.Illustration({
      element: '.zdog-canvas-half-vector',
      dragRotate: false,
    });
    
  let rgbToString = function(r, g, b) {
    return "rgb("+r.toString() +","+g.toString()+","+b.toString()+")";
  }
  
  let hslaToString = function(r, g, b, a) {
    return "hsla("+r.toString() +","+g.toString()+"%,"+b.toString()+"%,"+a+")";
  }
  
  // vector maths
  let vAdd = (a,b) => ({x:a.x+b.x, y:a.y+b.y});
  let vLength = (a) => (Math.sqrt(Math.pow(a.x,2) + Math.pow(a.y, 2)));
  let vScalar = (a, s) => ({x: a.x * s, y: a.y * s});
  let vSub = (a,b) => vAdd(a, vScalar(b, -1));
  let vNormalize = (a) => vScalar(a, 1 / vLength(a));
  let vPerpendicular = (a) => (Math.sign(a.x) == Math.sign(a.y) ? {x:a.y, y:-a.x} : {x:-a.y, y:a.x});
  let getPathDirection = (angle, radius) => (vScalar({x: Math.sin(angle), y: -Math.cos(angle)}, radius)); // angle is between the ground and the vector
  let getPath = (origin, angle, radius) => [origin, vAdd(origin, getPathDirection(angle, radius))];
  let p = (x,y) =>  ({x:x, y:y});
  
  const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
  
  
  let getTrianglePoints = function(v, alpha) {
    let arrowHeight = 50 * zoom;
    let arrowWidth = 30 * zoom;

    let x = Math.sin(alpha) * arrowHeight;
    let y = -Math.cos(alpha) * arrowHeight;
  
    let A = {x: v.x - x, y: v.y - y};
    let B = {x: v.x - x, y: v.y - y};
    let C = v;
  
  
    let deltaX = -Math.cos(alpha) * arrowWidth / 2.0;
    let deltaY = -Math.sin(alpha) * arrowWidth / 2.0;
  
    A = vAdd(A, p(deltaX, deltaY));
    B = vSub(B, p(deltaX, deltaY));
  
    return [A, B, C];
  }


  let zoom = 0.5;
  // initialize trigonometry parameters-----------------
  let alpha0 = -20.0 * Math.PI / 180.0;
  let alpha = alpha0;
  let l = 500 * zoom; // light ray length
  let b = Math.cos(alpha) * l; // normal height
  let alpha02 = 70.0 * Math.PI / 180.0;
  let alpha2 = alpha02;
  let l2 = 600 * zoom; // view ray length
  // ---------------------------------------------------
  
  
  // rgb [14, 223, 241];
  let gColor0 = [185, 89, 50];
  let gColor = [0, 0, 255];
  //TODO: update for specular lighting
  let shade = Math.cos(alpha);
  
  let leftBorder = -520 * zoom;
  let rightBorder = 520 * zoom;
  
  let startY = 200 * zoom;
  let center = 0.5 * (leftBorder + rightBorder);
  
  let origin = {x:center, y: startY};
  
  let groundHeight = 50;

  // constant shapes (aside from color)
  let ground  = new Zdog.Shape({
    addTo: illo2,
    path: [
      { x: leftBorder, y: startY + groundHeight, z:1}, // start at 1st point
      { x: leftBorder, y: startY, z:1}, // start at 1st point
      { x:  rightBorder, y: startY, z:1 }, // line to 2nd point
      { x:  rightBorder, y: startY + groundHeight, z:1 }, // line to 2nd point
    ],
    stroke: 10 * zoom,
    closed: false,
    color: hslaToString(gColor[0],gColor[1],gColor[2]*shade, 1.0),
  });
  
  
  let canvasCoordinates = function(x,y) {
    let canvasRect = document.getElementsByClassName("zdog-canvas-half-vector")[0].getBoundingClientRect();
    let height = canvasRect.height;
    let width = canvasRect.width;
    return{x: (x-canvasRect.x - width/2.0), y:-( y-canvasRect.y-height/2.0) + startY};
  };
  
  let ground2 = ground.copy({
    fill:true,
    color: "hsla(0,0%,80%,0.18)",});
  let normal  = new Zdog.Shape({
    addTo: illo2,
    path: getPath(origin, 0, b),
    stroke: 10 * zoom,
    color: hslaToString(gColor[0],gColor[1],gColor[2]*shade, 1.0),
  });
  let normalTip  = new Zdog.Shape({
    addTo: illo2,
    path: getTrianglePoints(normal.path[1], 0),
    stroke: 5*zoom,
    color: hslaToString(gColor[0],gColor[1],gColor[2]*shade, 1.0),
    fill: true
  });
    
  
  // directly modified by angle
  let lightLine = new Zdog.Shape({
    addTo: illo2,
    stroke: 5 * zoom,
    translate: {z:1},
  });
  let lightTriangle = new Zdog.Shape({
    addTo: illo2,
    stroke: 0,
    translate:{z:1},
    fill: true
  });
  
  // reflection light ray
  let reflectionLine = lightLine.copy();
  let reflectionTriangle = lightTriangle.copy();
  // view light ray
  let viewLine = lightLine.copy();
  let viewTriangle = lightTriangle.copy();
  
  let updateLightLine = function() {
    lightLine.path = getPath(origin, alpha, l);
    lightLine.updatePath();
  
    lightTriangle.path = getTrianglePoints(lightLine.path[1], alpha);
    lightTriangle.updatePath();
  };
  let updateReflectionLine = function() {
    reflectionLine.path = getPath(origin, - alpha, l);
    reflectionLine.updatePath();
  
    reflectionTriangle.path = getTrianglePoints(reflectionLine.path[1], -alpha);
    reflectionTriangle.updatePath();
  };
  let updateViewLine = function() {
    viewLine.path = getPath(origin, alpha2, l2)
    viewLine.updatePath();
  
    viewTriangle.path = getTrianglePoints(viewLine.path[1], alpha2);
    viewTriangle.updatePath();
  }
  
  updateLightLine();
  updateReflectionLine();
  updateViewLine();
  
  let lineColor = () => [255, 15, 200];
  let lineColor2 = () => [14, 223, 241];
  
    
  let magenta = lineColor();
  let cyan = lineColor2();
  let magentaString = rgbToString(magenta[0], magenta[1], magenta[2]);
  let cyanString = rgbToString(cyan[0], cyan[1], cyan[2]);
  
  lightLine.color = magentaString;
  lightTriangle.color = magentaString;
  reflectionLine.color = magentaString;
  reflectionTriangle.color = magentaString;
  viewLine.color = cyanString;
  viewTriangle.color = cyanString;
  
  let arc = lightLine.copy({closed: false, color:hslaToString(gColor0[0],gColor0[1],gColor0[2], 1.0)});
  let arc2 = lightLine.copy({closed: false, color:hslaToString(gColor0[0],gColor0[1],gColor0[2], 1.0)});
  let arcView = lightLine.copy({closed: false, color: hslaToString(gColor[0],gColor[1],gColor[2], 1.0)});
  
  let getMirroredArc = function(path) {
    let p1 = path[0];
    let c1 = path[1].bezier[0];
    let c2 = path[1].bezier[1];
    let p2 = path[1].bezier[2];
  
    c1.x *= -1;
    c2.x *= -1;
    p2.x *= -1;
    return [p1, {bezier: [c1, c2, p2]}];
  }
  let getArcFromStuff0 = function(alpha, center, startY, radius, mirrored = false) {
    let part = 1.7;
    let point1 = {x:center , y:startY-radius};
    let point2 = {x:center - Math.sin(Math.PI/2.0-alpha) * radius , y:startY - Math.cos(Math.PI/2.0 - alpha) * radius};
    let middlePoint = {x:center - Math.tan(Math.PI/4.0 - alpha/2.0) * radius , y:startY - radius};
  
    let vector1 = {x:(middlePoint.x - point1.x) / part, y:(middlePoint.y - point1.y)/part};
    let vector2 = {x:(middlePoint.x - point2.x) / part, y:(middlePoint.y - point2.y)/part};
  
    let controlPoint1 = vAdd(point1, vector1);
    let controlPoint2 = vAdd(point2, vector2);
  
    let path = [point1, {bezier:[controlPoint1,controlPoint2,point2]}];
    return mirrored ? getMirroredArc(path) : path;
  }
  let getArcFromStuff = function(alpha1, alpha2, origin, radius, mirrored = false) {
    let part = 1.7;
    let point1 = vAdd(origin, getPathDirection(alpha1, radius));//vAdd(origin, p(0, -radius));
    let point2 = vAdd(origin, getPathDirection(alpha2, radius));

    let alphaDifference = Math.abs(alpha1 - alpha2);
    let middlePointRadius = radius / Math.cos(alphaDifference / 2.0);
    let middleAlpha = 0.5 * (alpha1 + alpha2);
    let middlePoint = vAdd(origin, getPathDirection(middleAlpha, middlePointRadius));
  
    let vector1 = vScalar(vSub(middlePoint, point1), 1.0/part);
    let vector2 = vScalar(vSub(middlePoint, point2), 1.0/part)
  
    let controlPoint1 = vAdd(point1, vector1);
    let controlPoint2 = vAdd(point2, vector2);
  
    let path = [point1, {bezier:[controlPoint1,controlPoint2,point2]}];
    return mirrored ? getMirroredArc(path) : path;
  }
  let updateBezierControlPoints = function() {
    let radiusView = 280;
    let radius = 240;
  
    arc.path = getArcFromStuff(0, alpha, p(center, startY), radius * zoom);
    arc2.path = getMirroredArc(JSON.parse(JSON.stringify(arc.path)));
    arcView.path =  getArcFromStuff(alpha2, -alpha,p(center, startY), radiusView * zoom, false);
    arc.updatePath();
    arc2.updatePath();
    arcView.updatePath();
  }
  updateBezierControlPoints();
  
    let leftSide = false;
    let angleDifference;
    let movedRay = 0;
    new Zdog.Dragger({
      startElement:illo2.element,
      onDragStart:function(pointer){
        let coords = canvasCoordinates(pointer.x, pointer.y);
        leftSide = (coords.x < 0.0);
        // TODO: refactor this abomination
        let angle = Math.atan(coords.x / coords.y);
        let angleLight = alpha;
        let angleReflect = -alpha;
        let angleView = alpha2;
        /* debug statements in case everything breaks again
        console.log("angle 1");
        console.log(angleLight);
        console.log("angle 2");
        console.log(angleReflect);
        console.log("angle 3");
        console.log(angleView);
        console.log(angle);*/
        let angleDifference1 = angle-angleLight;
        let angleDifference2 = angle-angleReflect;
        let angleDifference3 = angle-angleView;
        if(Math.abs(angleDifference1) < Math.abs(angleDifference2)) {
          if(Math.abs(angleDifference1) < Math.abs(angleDifference3)) {
            angleDifference = angleDifference1;
            movedRay = 0;
          } else {
            angleDifference = angleDifference3;
            movedRay = 2;
          }
        } else if(Math.abs(angleDifference3) < Math.abs(angleDifference2)) {
          angleDifference = angleDifference3;
          movedRay = 2;
        } else {
          angleDifference = angleDifference2;
          movedRay = 1;
        }
        arc2.color = hslaToString(gColor0[0],gColor0[1],gColor0[2], 0.5);
        reflectionLine.color = rgbToString(magenta[0] * 0.5, magenta[1] * 0.5, magenta[2] * 0.5);
        reflectionTriangle.color = rgbToString(magenta[0] * 0.5, magenta[1] * 0.5, magenta[2] * 0.5);
      },
      onDragMove:function(pointer, moveX, moveY) {
        let coords = canvasCoordinates(pointer.x, pointer.y);
        let angle = Math.atan(coords.x / coords.y);
        // TODO for if I have time some day: determine the quadrant the angle is in to correctly find angles for y < 0
        if(coords.y < 0) return;
        if(movedRay == 0) {
          alpha = (angle - angleDifference);
          alpha = clamp(alpha, -0.5*Math.PI+0.2, -0.2);
        } else if (movedRay == 1) {
          alpha =  -(angle - angleDifference);
          alpha = clamp(alpha, -0.5*Math.PI+0.2, -0.2);
        } else {
          alpha2 = (angle - angleDifference);
          alpha2 = clamp(alpha2, 0.2, 0.5*Math.PI-0.2);
  
        }
        //calculateLightRayParameters();
        
        updateLightLine();
        updateReflectionLine();
        updateViewLine();
        
        updateBezierControlPoints();
  
        shade = Math.cos(Math.PI / 2.0 - alpha);
        ground.color = hslaToString(gColor[0], gColor[1], gColor[2] * shade, 1.0);
      },
      onDragEnd:function(){
        alpha0 = alpha;
        alpha02 = alpha2;
  
        arc2.color = hslaToString(gColor0[0],gColor0[1],gColor0[2], 1.0);
        reflectionLine.color = rgbToString(magenta[0], magenta[1], magenta[2]);
        reflectionTriangle.color = rgbToString(magenta[0] , magenta[1] , magenta[2]);
      }
    });
    illo2.zoom = 0.5;
    function animate() {
      illo2.updateRenderGraph();
      requestAnimationFrame( animate );
    }
    
    animate();
  
  </script><script>// Made with Zdog

let aaaa = function() {
let illo = new Zdog.Illustration({
  element: '.zdog-canvas',
  dragRotate: false,
});

let rgbToString = function(r, g, b) {
  return "rgb("+r.toString() +","+g.toString()+","+b.toString()+")";
}
let hslaToString = function(r, g, b, a) {
  return "hsla("+r.toString() +","+g.toString()+"%,"+b.toString()+"%,"+a+")";
}

let getTrianglePoints = function(x, y, alpha) {
  let arrowHeight = 50;
  let arrowWidth = 30;

  let o = Math.sin(alpha) * arrowHeight;
  let p = Math.cos(alpha) * arrowHeight;

  let A = {x: x - p, y: y - o};
  let B = {x: x - p, y: y - o};
  let C = {x: x, y: y};

  let beta = Math.PI / 2.0 - alpha;

  let i = Math.cos(beta) * arrowWidth / 2.0;
  let j = Math.sin(beta) * arrowWidth / 2.0;

  A.x -= i;
  A.y += j;

  B.x += i;
  B.y -= j;

  return [A, B, C];
}

const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

let alpha0 = 70.0 * Math.PI / 180.0;
let alpha = alpha0;
let a = 100; // distance between light rays
let b = 500; // height of light rays
let c = b / Math.tan(alpha);
let h = a / Math.sin(alpha);

// rgb [14, 223, 241];
let gColor0 = [185, 89, 50];
let gColor = gColor0;
let lambert = Math.cos(Math.PI / 2.0 - alpha);

let leftBorder = -520;
let rightBorder = 520;
let ground  = new Zdog.Shape({
  addTo: illo,
  path: [
    { x: leftBorder, y: 300, z:1}, // start at 1st point
    { x: leftBorder, y: 200, z:1}, // start at 1st point
    { x:  rightBorder, y: 200, z:1 }, // line to 2nd point
    { x:  rightBorder, y: 300, z:1 }, // line to 2nd point
  ],
  stroke: 10,
  closed: false,
  color: hslaToString(gColor[0],gColor[1],gColor[2]*lambert, 1.0),
});

let ground2 = ground.copy({
  fill:true,
  color: "hsla(185,89%,50%,0.08)",});

let startX = -0;
let startY = -300;
let fadeRange = 50;

let lines = [];
let triangles = [];
triangles.push(new Zdog.Shape({
  addTo: illo,
  path: getTrianglePoints(startX, startY+ b, alpha),
  stroke: 0,
  translate:{z:1},
  visible: false,
  fill: true
}));

lines.push(new Zdog.Shape({
  addTo: null,
  path: [
    { x: startX-c, y: startY}, // start at 1st point
    { x:  startX, y: startY + b }, // line to 2nd point
  ],
  stroke: 5,
  translate:{z:1},
  visible: false
}));

let fadeFormula = function(h, i) {
  let left = startX + h * i - leftBorder;
  let right = rightBorder - (startX  + h * i);
  let leftClamped = clamp(left, 0, fadeRange) * (1 / fadeRange);
  let rightClamped =  clamp(right, 0, fadeRange) * (1 / fadeRange);
  return leftClamped * rightClamped;
}
let lineColorFromI = (i) => [255, 15, i * 20 + 200];

for(let i = -9; i < 9; i++) {
  
  lines.push(
      lines[0].copy(
          {
              visible:true,
              addTo: illo,
              translate: {x:h * i}
          }
      )
  );

  triangles.push(triangles[0].copy(
    {
        visible:true,
        addTo: illo,
        translate: {x:h * i}
    }
));

  let baseColor = lineColorFromI(i);
  let factor = fadeFormula(h, i);
  lines[i+10].color = rgbToString(baseColor[0] * factor, baseColor[1] * factor, baseColor[2] * factor);
  triangles[i+10].color = rgbToString(baseColor[0] * factor, baseColor[1] * factor, baseColor[2] * factor);

}
let getDistanceMarker = function(x, y, h, b) {
 let height = 50;
return [
{ x: x , y: y +b +height}, // start at 1st point
{ x: x  + h, y: y +b+height} // start at 1st point
]
};
let distance  = new Zdog.Shape({
  addTo: illo,
  path: getDistanceMarker(startX, startY, h, b),
  stroke: 5,
  closed: false,
  color: hslaToString(185, 0, 100, 1.0),
});
let path = getDistanceMarker(startX, startY, h, b);
let pointA = path[0];
let pointB = path[1];
let distanceA  = new Zdog.Shape({
  addTo: illo,
  path: [
    {x: pointA.x, y: pointA.y-15},
    {x: pointA.x, y: pointA.y+15},
  ],
  stroke: 5,
  closed: false,
  color: hslaToString(185, 0, 100, 1.0),
});
let distanceB  = new Zdog.Shape({
  addTo: illo,
  path: [
    {x: pointB.x, y: pointB.y-15},
    {x: pointB.x, y: pointB.y+15},
  ],
  stroke: 5,
  closed: false,
  color: hslaToString(185, 0, 100, 1.0),
});
let distance2  = new Zdog.Shape({
  addTo: illo,
  path: [
    { x: startX, y: startY+b}, // start at 1st point
    { x: startX + Math.cos(Math.PI / 2 - alpha) * a, y: b+startY - Math.sin(Math.PI / 2 - alpha) * a} // start at 1st point
  ],
  stroke: 5,
  closed: false,
  color: "#888",
  visible: false,
});

new Zdog.Dragger({
  startElement:illo.element,
  onDragStart:function(){},
  onDragMove:function(pointer, moveX, moveY) {
    alpha =  alpha0 + moveX/300.0;
    alpha = clamp(alpha, 0.2, Math.PI-0.2);
    c = b / Math.tan(alpha); 
    h = a / Math.sin(alpha);
    for(let i = -9; i <9; i++) {
        lines[i+10].path = [
          {x: startX - c, y: startY},
          {x:  startX, y: startY + b}
        ];
      lines[i+10].translate = {x: h * i};
      lines[i+10].updatePath();

      let baseColor = lineColorFromI(i);
      let factor = fadeFormula(h,i);
      lines[i+10].color = rgbToString(baseColor[0] * factor, baseColor[1] * factor, baseColor[2] * factor);
    
      triangles[i+10].path = getTrianglePoints(startX, startY+b, alpha);
      triangles[i+10].updatePath();
      triangles[i+10].translate = {x: h * i};
      triangles[i+10].color = rgbToString(baseColor[0] * factor, baseColor[1] * factor, baseColor[2] * factor);
    
    }

    let path = getDistanceMarker(startX, startY, h, b);
    let pointA = path[0];
    let pointB = path[1];
    distance.path = path;
    distanceA.path = [
      {x: pointA.x, y: pointA.y-15},
      {x: pointA.x, y: pointA.y+15},
    ];
    distanceB.path = [
      {x: pointB.x, y: pointB.y-15},
      {x: pointB.x, y: pointB.y+15},
    ];
    distance.updatePath();
    distanceA.updatePath();
    distanceB.updatePath();


    distance2.path =  [
      { x: startX, y: startY+b}, // start at 1st point
      { x: startX + Math.cos(Math.PI / 2 - alpha) * a, y: b+startY - Math.sin(Math.PI / 2 - alpha) * a} // start at 1st point
    ];
    distance2.updatePath();

    lambert = Math.cos(Math.PI / 2.0 - alpha);
    ground.color = hslaToString(gColor[0], gColor[1], gColor[2] * lambert, 1.0);
  },
  onDragEnd:function(){
    alpha0 = alpha;
  }
});
illo.zoom = 0.5;
function animate() {
  illo.updateRenderGraph();
  requestAnimationFrame( animate );
}

animate();}

aaaa();</script><footer class="container"><div class="row text-center"><div class="col-12"><p class="mt-5 mb-1">&copy; 2022
Hasso-Plattner-Institut f√ºr Digital Engineering gGmbH</p><small class="mt-0 mb-5"><a class="text-muted" href="https://docs.github.com/en/github/site-policy/github-privacy-statement">Datenschutzerkl√§rung</a></small></div></div><data hidden value="eb986236984a858c85bbd503b68dcf8fe133dfa7">revision</data></footer></body><script src="../jquery.min.js"></script><script src="../bootstrap.js"></script><script src="../scripts.js"></script></html>