<!DOCTYPE html><html lang="en"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta charset="utf-8"><meta name="viewport" content="width=device-widthinitial-scale=1"><title>CG-Session</title><meta name="description" content="ToDo"><meta name="robots" content="index, follow"><link rel="stylesheet" href="../styles.css"><noscript><style class="js-only">{ display: none; }</style></noscript><body id="page-top" data-spy="scroll"><section class="container" id="lecture"><div class="row text-center"><div class="col-12"><div class="title"><img class="img-fluid" src="../webp-generated/witness_bec0.webp"><h2>Parametrische <strong>Kurven</strong> und <strong>Flächen</strong></h2></div><a href="../index.html">Zurück zu <strong>Vorlesungsübersicht</strong></a></div></div></section><script src="../paper-full.min.js"></script><div class="container"><div class="row"><div class="offset-1 col-10"><div class="alert alert-secondary"><p>In dieser Einheit werden die Grundlagen parametrischer Kurven und Flächen erklärt.</p><hr><h4>Nach dieser Lehreinheit solltest du&hellip;</h4><ul class="list-unstyled"><li>&hellip;wissen, wie sich Kurven mathematisch darstellen lassen,</li><li>&hellip;verschiedene Kontinuitätseigenschaften kennen und zuordnen können,</li><li>&hellip;Darstellungsweisen, Eigenschaften und Anwendungen von Bézier-Kurven kennen.</li></ul></div></div></div><div class="row"><div class="offset-1 col-10"><div class="alert alert-primary"><h4>Vorwissen</h4><ul class="list-unstyled"><li>&hellip;Verständnis für Grundlagen der <b>Vektorrechnung</b></li></ul><h4>Einführung in Splines</h4><ul class="list-unstyled"><li>&hellip;<a href="https://www.youtube.com/watch?v=jvPPXbo87ds">The Continuity of Splines </a> von Freya Holmér</li></ul></div></div></div></div><section class="container"><div class="row"><div class="offset-1 col-10"><h3>Motivation und Problemstellung</h3> <p>Kurven sind überall wir wollen sie beschreiben, bauen und analysieren yeah yeah</p> <p>beispiele für kurven</p> <p><canvas id="demo1" resize></canvas> <img hidden="true" id="curve_hint" src="../webp-generated/curve_hint_cbc4.png"></p> </div></div></section><section class="container"><div class="row"><div class="offset-1 col-10"><h3>Motivation und Problemstellung</h3> <p>Kurven sind überall wir wollen sie beschreiben, bauen und analysieren yeah yeah</p> <p>beispiele für kurven</p> </div></div></section><script>
window.onload = function() {
  // Get a reference to the canvas object
  var canvas = document.getElementById('demo1');
  // Create an empty project and a view for the canvas:
  paper.setup(canvas);

  var tool = new paper.Tool();
  //tool.minDistance = 10;
  //tool.maxDistance = 10;
  var t = 0.8;

  paper.view.draw();
  var path;
  var path1;
  var path2;
  var circle;
  var text;
  var pbText;

  var hint = new paper.Raster('curve_hint');
  hint.position = paper.view.center;
  hint.scale(0.15);

  var pbSize = new paper.Size(400,14);
  var pbYOffset = -150;
  var pbOffset = new paper.Point(-pbSize.width / 2,pbYOffset -pbSize.height / 2);
  var pbRadius = pbSize.height / 2;
  var pbPoint = paper.view.center.add(pbOffset);
  var progressBarBack = new paper.Path.Rectangle(new paper.Rectangle(pbPoint, pbSize), pbRadius);
  progressBarBack.fillColor = 'lightGrey';

  var progressBarFront;
  function createFrontProgressBar(t){
    if(progressBarFront && progressBarFront.parent) {
      progressBarFront.remove();
    }
    var pbFrontSize = pbSize.clone();
    pbFrontSize.width *= t;
    progressBarFront = new paper.Path.Rectangle(new paper.Rectangle(pbPoint, pbFrontSize), pbRadius);
    progressBarFront.fillColor = 'magenta';
  }

  //var progressBarFront = progressBarBack.clone();
  //progressBarFront.fillColor = 'magenta';
  //progressBarFront.scale(t, 1, pbPoint);

  function inverseRemove(thing) {
    paper.project.activeLayer.addChild(thing);
  }

  function updatePathProgress(path, t) {
    path1?.remove();
    path2?.remove();
    inverseRemove(path);

    path1 = path.clone();
    path.remove();

    path2 = path1.splitAt(path.length*t);
    if(path2)  {
      path2.strokeColor = 'lightGrey';
      path2.strokeWidth =3;
    }
    path1.strokeWidth =5;

    if(!path1.lastSegment) return;
    var splitPoint = path1.lastSegment.point;
    var curveCoordinates = splitPoint.subtract(paper.view.center).divide(40.0);

    if(!circle || !circle.parent) {
      circle = new paper.Path.Circle({
        radius:8,
        fillColor: 'white',
        strokeColor: path1.strokeColor,
        strokeWidth:5
      });
    }
    else circle.bringToFront();

    if(!text || !text.parent) {
      text = new paper.PointText({
        fontSize: 16,
        fillColor: path1.strokeColor,
        fontWeight: 'bold'
      });
    }
    else text.bringToFront();
    
    if(!pbText || !pbText.parent) {
      pbText = text.clone();
    }
    
    circle.position = (splitPoint);
    
    text.content = curveCoordinates.x.toFixed(1)+"|"+curveCoordinates.y.toFixed(1);
    var offset = new paper.Point(20,-20);
    text.position = (splitPoint.add(offset));

    createFrontProgressBar(t);
    progressBarFront.fillColor = path1.strokeColor;
    
    pbText.content = t.toFixed(2);
    var pbBounds = progressBarFront.bounds;
    offset = new paper.Point(0,-15);
    pbText.position = pbBounds.topRight.add(offset);

    paper.view.draw();
  }

  function removeAllOldStuff(){
    
    //remove old (split) curve
    path1?.remove();
    path2?.remove();
    circle?.remove();
    text?.remove();
    pbText?.remove();
  }

  var progressSelected = false;
  var pathDone = false;
  tool.onMouseDown = function(event){
    if(event.point.y < progressBarBack.bounds.bottom) {
      progressSelected = true;
      return;
    }
    hint.remove();

    pathDone = false;
    progressSelected = false;

    removeAllOldStuff();

    path = new paper.Path();
    path.strokeColor = paper.Color.random();
    path.strokeCap = 'round';
  }

  tool.onMouseDrag = function(event) {
    if(progressSelected) {
      t = Math.min(1.0, Math.max(0.0, event.point.x-pbPoint.x)/pbSize.width);
      //if(path) updatePathProgress(path);
      return;
    }
    path.add(event.point);
    
    paper.view.draw();
  }

  tool.onMouseUp = function(event){
    if(progressSelected) {
      return;
    }
    path.simplify(1000.0);
    pathDone = true;

    //updatePathProgress(path);
  }

  tool.onKeyDown = function(event) {
    var delta = 0.01;
    if(event.key == "a") t = Math.max(t-delta, 0.0);
    if(event.key == "d") t = Math.min(t+delta, 1.0);
  
    //updatePathProgress(path);
  }

  var progressT = t;
  paper.project.activeLayer.onFrame = function (event) {
    var delta = t - progressT;
    progressT += delta /20;
    if(Math.abs(progressT - t)<0.0001) progressT = t;
    if(pathDone) updatePathProgress(path, progressT);
  }
}</script><footer class="container"><div class="row text-center"><div class="col-12"><p class="mt-5 mb-1">&copy; 2021&ndash;2023
Universität Potsdam &ndash; Digital Engineering Fakultät &ndash; Hasso-Plattner-Institut für Digital Engineering gGmbH</p><small class="mt-0 mb-5"><a class="text-muted" href="https://docs.github.com/en/github/site-policy/github-privacy-statement">Datenschutzerklärung</a></small></div></div><data hidden value="65b354892baf15f3f0c1d2892e160eea36bfc61a">revision</data></footer></body><script src="../jquery.min.js"></script><script src="../bootstrap.js"></script><script src="../scripts.js"></script><script src="../paper.js"></script></html>